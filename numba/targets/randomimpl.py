"""
Implement the cmath module functions.
"""

from __future__ import print_function, absolute_import, division

import random
import math

from llvmlite import ir

from numba.targets.imputils import implement, Registry
from numba.typing import signature
from numba import _helperlib, cgutils, errcode, types, utils


registry = Registry()
register = registry.register

int32_t = ir.IntType(32)
int64_t = ir.IntType(64)
def const_int(x):
    return ir.Constant(int32_t, x)
double = ir.DoubleType()

N = 624
N_const = ir.Constant(int32_t, N)

# This is the same struct as rnd_state_t in _helperlib.c.
rnd_state_t = ir.LiteralStructType(
    [int32_t, ir.ArrayType(int32_t, N),
     int32_t, double])
rnd_state_ptr_t = ir.PointerType(rnd_state_t)

# Accessors
def get_index_ptr(builder, state_ptr):
    return cgutils.gep(builder, state_ptr, 0, 0)

def get_array_ptr(builder, state_ptr):
    return cgutils.gep(builder, state_ptr, 0, 1)

def get_has_gauss_ptr(builder, state_ptr):
    return cgutils.gep(builder, state_ptr, 0, 2)

def get_gauss_ptr(builder, state_ptr):
    return cgutils.gep(builder, state_ptr, 0, 3)


def get_next_int32(context, builder, state_ptr):
    """
    Get the next int32 generated by the PRNG at *state_ptr*.
    """
    idxptr = get_index_ptr(builder, state_ptr)
    idx = builder.load(idxptr)
    need_reshuffle = builder.icmp_unsigned('>=', idx, N_const)
    with cgutils.if_unlikely(builder, need_reshuffle):
        fnty = ir.FunctionType(ir.VoidType(), (rnd_state_ptr_t,))
        fn = builder.function.module.get_or_insert_function(fnty, "numba_rnd_shuffle")
        builder.call(fn, (state_ptr,))
        builder.store(const_int(0), idxptr)
    idx = builder.load(idxptr)
    array_ptr = get_array_ptr(builder, state_ptr)
    y = builder.load(cgutils.gep(builder, array_ptr, 0, idx))
    idx = builder.add(idx, const_int(1))
    builder.store(idx, idxptr)
    # Tempering
    y = builder.xor(y, builder.lshr(y, const_int(11)))
    y = builder.xor(y, builder.and_(builder.shl(y, const_int(7)),
                                    const_int(0x9d2c5680)))
    y = builder.xor(y, builder.and_(builder.shl(y, const_int(15)),
                                    const_int(0xefc60000)))
    y = builder.xor(y, builder.lshr(y, const_int(18)))
    return y

def get_next_double(context, builder, state_ptr):
    """
    Get the next double generated by the PRNG at *state_ptr*.
    """
    # a = rk_random(state) >> 5, b = rk_random(state) >> 6;
    a = builder.lshr(get_next_int32(context, builder, state_ptr), const_int(5))
    b = builder.lshr(get_next_int32(context, builder, state_ptr), const_int(6))

    # return (a * 67108864.0 + b) / 9007199254740992.0;
    a = builder.uitofp(a, double)
    b = builder.uitofp(b, double)
    return builder.fdiv(
        builder.fadd(b, builder.fmul(a, ir.Constant(double, 67108864.0))),
        ir.Constant(double, 9007199254740992.0))

def get_next_int(context, builder, state_ptr, nbits):
    """
    Get the next integer with width *nbits*.
    """
    c32 = ir.Constant(nbits.type, 32)
    def get_shifted_int(nbits):
        shift = builder.sub(c32, nbits)
        y = get_next_int32(context, builder, state_ptr)
        return builder.lshr(y, builder.zext(shift, y.type))

    ret = cgutils.alloca_once_value(builder, ir.Constant(int64_t, 0))

    is_32b = builder.icmp_unsigned('<=', nbits, c32)
    with cgutils.ifelse(builder, is_32b) as (ifsmall, iflarge):
        with ifsmall:
            low = get_shifted_int(nbits)
            builder.store(builder.zext(low, int64_t), ret)
        with iflarge:
            # XXX This assumes nbits <= 64
            low = get_next_int32(context, builder, state_ptr)
            high = get_shifted_int(builder.sub(nbits, c32))
            total = builder.add(
                builder.zext(low, int64_t),
                builder.shl(builder.zext(high, int64_t), ir.Constant(int64_t, 32)))
            builder.store(total, ret)

    return builder.load(ret)


def get_py_state_ptr(context, builder):
    return context.get_c_value(builder, rnd_state_t,
                               "numba_py_random_state")


@register
@implement("random.seed", types.uint32)
def seed_impl(context, builder, sig, args):
    seed_value, = args
    state_ptr = get_py_state_ptr(context, builder)
    fnty = ir.FunctionType(ir.VoidType(), (rnd_state_ptr_t, int32_t))
    fn = builder.function.module.get_or_insert_function(fnty, "numba_rnd_init")
    builder.call(fn, (state_ptr, seed_value))
    return context.get_constant(types.none, None)

@register
@implement("random.random")
def random_impl(context, builder, sig, args):
    state_ptr = get_py_state_ptr(context, builder)
    return get_next_double(context, builder, state_ptr)


@register
@implement("random.gauss", types.Kind(types.Float), types.Kind(types.Float))
def gauss_impl(context, builder, sig, args):
    mu, sigma = args

    state_ptr = get_py_state_ptr(context, builder)
    # The type for all computations (either float or double)
    ty = sig.return_type
    llty = context.get_data_type(ty)

    ret = cgutils.alloca_once(builder, llty, name="result")

    gauss_ptr = get_gauss_ptr(builder, state_ptr)
    has_gauss_ptr = get_has_gauss_ptr(builder, state_ptr)
    has_gauss = cgutils.is_true(builder, builder.load(has_gauss_ptr))
    with cgutils.ifelse(builder, has_gauss) as (then, otherwise):
        with then:
            # if has_gauss: return it
            builder.store(builder.load(gauss_ptr), ret)
            builder.store(const_int(0), has_gauss_ptr)
        with otherwise:
            # if not has_gauss: compute a pair of numbers using the Box-Muller
            # transform; keep one and return the other
            zero = ir.Constant(llty, 0.0)
            one = ir.Constant(llty, 1.0)
            two = ir.Constant(llty, 2.0)

            bbwhile = cgutils.append_basic_block(builder, "while")
            bbend = cgutils.append_basic_block(builder, "while.end")
            builder.branch(bbwhile)

            # do {
            builder.position_at_end(bbwhile)
            #   x1 = 2.0*rk_double(state) - 1.0
            #   x2 = 2.0*rk_double(state) - 1.0
            x1 = builder.fsub(
                builder.fmul(two, get_next_double(context, builder, state_ptr)),
                one)
            x2 = builder.fsub(
                builder.fmul(two, get_next_double(context, builder, state_ptr)),
                one)
            #   r2 = x1*x1 + x2*x2
            r2 = builder.fadd(builder.fmul(x1, x1),
                              builder.fmul(x2, x2))
            # } while (r2 >= 1.0 || r2 == 0.0)
            cond_retry = builder.or_(
                builder.fcmp_ordered('>=', r2, one),
                builder.fcmp_ordered('==', r2, zero))
            builder.cbranch(cond_retry, bbwhile, bbend)

            # f = sqrt(-2.0*log(r2)/r2)
            builder.position_at_end(bbend)
            log = context.get_function(math.log, signature(ty, ty))
            sqrt = context.get_function(math.sqrt, signature(ty, ty))

            logr2 = log(builder, (r2,))
            sqf = builder.fsub(zero,
                               builder.fdiv(builder.fmul(two, logr2), r2))
            f = sqrt(builder, (sqf,))

            # Store f*x1, return f*x2
            builder.store(builder.fmul(f, x1), gauss_ptr)
            builder.store(builder.fmul(f, x2), ret)
            builder.store(const_int(1), has_gauss_ptr)

    return builder.fadd(mu,
                        builder.fmul(sigma, builder.load(ret)))

@register
@implement("random.getrandbits", types.Kind(types.Integer))
def getrandbits_impl(context, builder, sig, args):
    nbits, = args
    state_ptr = get_py_state_ptr(context, builder)
    return get_next_int(context, builder, state_ptr, nbits)


def _randrange_impl(context, builder, start, stop, step):
    state_ptr = get_py_state_ptr(context, builder)

    ty = stop.type
    zero = ir.Constant(ty, 0)
    one = ir.Constant(ty, 1)
    nptr = cgutils.alloca_once(builder, ty, name="n")
    # n = stop - start
    builder.store(builder.sub(stop, start), nptr)

    with cgutils.ifthen(builder, builder.icmp_signed('<', step, zero)):
        # n = (n + step + 1) // step
        w = builder.add(builder.add(builder.load(nptr), step), one)
        n = builder.sdiv(w, step)
        builder.store(n, nptr)
    with cgutils.ifthen(builder, builder.icmp_signed('>', step, one)):
        # n = (n + step - 1) // step
        w = builder.sub(builder.add(builder.load(nptr), step), one)
        n = builder.sdiv(w, step)
        builder.store(n, nptr)

    n = builder.load(nptr)
    with cgutils.if_unlikely(builder, builder.icmp_signed('<=', n, zero)):
        # n <= 0 => ValueError
        context.return_errcode(builder, errcode.RUNTIME_ERROR)

    fnty = ir.FunctionType(ty, [ty, cgutils.true_bit.type])
    fn = builder.function.module.get_or_insert_function(fnty, "llvm.ctlz.%s" % ty)
    nbits = builder.trunc(builder.call(fn, [n, cgutils.true_bit]), int32_t)
    nbits = builder.sub(ir.Constant(int32_t, ty.width), nbits)

    bbwhile = cgutils.append_basic_block(builder, "while")
    bbend = cgutils.append_basic_block(builder, "while.end")
    builder.branch(bbwhile)

    builder.position_at_end(bbwhile)
    r = get_next_int(context, builder, state_ptr, nbits)
    r = builder.trunc(r, ty)
    too_large = builder.icmp_signed('>=', r, n)
    builder.cbranch(too_large, bbwhile, bbend)

    builder.position_at_end(bbend)
    return builder.add(start, builder.mul(r, step))


@register
@implement("random.randrange", types.Kind(types.Integer))
def randrange_impl_1(context, builder, sig, args):
    stop, = args
    start = ir.Constant(stop.type, 0)
    step = ir.Constant(stop.type, 1)
    return _randrange_impl(context, builder, start, stop, step)

@register
@implement("random.randrange", types.Kind(types.Integer), types.Kind(types.Integer))
def randrange_impl_2(context, builder, sig, args):
    start, stop = args
    step = ir.Constant(start.type, 1)
    return _randrange_impl(context, builder, start, stop, step)

@register
@implement("random.randrange", types.Kind(types.Integer),
           types.Kind(types.Integer), types.Kind(types.Integer))
def randrange_impl_3(context, builder, sig, args):
    start, stop, step = args
    return _randrange_impl(context, builder, start, stop, step)

@register
@implement("random.randint", types.Kind(types.Integer), types.Kind(types.Integer))
def randint_impl(context, builder, sig, args):
    start, stop = args
    step = ir.Constant(start.type, 1)
    stop = builder.add(stop, step)
    return _randrange_impl(context, builder, start, stop, step)

@register
@implement("random.uniform", types.Kind(types.Float), types.Kind(types.Float))
def uniform_impl(context, builder, sig, args):
    state_ptr = get_py_state_ptr(context, builder)
    a, b = args
    width = builder.fsub(b, a)
    r = get_next_double(context, builder, state_ptr)
    return builder.fadd(a, builder.fmul(width, r))

@register
@implement("random.triangular", types.Kind(types.Float), types.Kind(types.Float))
def triangular_impl_2(context, builder, sig, args):
    fltty = sig.return_type
    low, high = args
    state_ptr = get_py_state_ptr(context, builder)
    randval = get_next_double(context, builder, state_ptr)

    def triangular_impl(randval, low, high):
        u = randval
        c = 0.5
        if u > c:
            u = 1.0 - u
            low, high = high, low
        return low + (high - low) * math.sqrt(u * c)

    return context.compile_internal(builder, triangular_impl,
                                    signature(*(fltty,) * 4),
                                    (randval, low, high))
