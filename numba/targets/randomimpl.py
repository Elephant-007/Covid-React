"""
Implement the cmath module functions.
"""

from __future__ import print_function, absolute_import, division

import random
import math

from llvmlite import ir

from numba.targets.imputils import implement, Registry
from numba import _helperlib, types, cgutils, utils


# TODO: auto-seeding at startup


registry = Registry()
register = registry.register

int32_t = ir.IntType(32)
int64_t = ir.IntType(64)
def const_int(x):
    return ir.Constant(int32_t, x)
double = ir.DoubleType()

N = 624
N_const = ir.Constant(int32_t, N)

# This is the same struct as rnd_state_t in _helperlib.c.
rnd_state_t = ir.LiteralStructType([int32_t, ir.ArrayType(int32_t, N)])
rnd_state_ptr_t = ir.PointerType(rnd_state_t)


def get_index_ptr(builder, state_ptr):
    return cgutils.gep(builder, state_ptr, 0, 0)

def get_array_ptr(builder, state_ptr):
    return cgutils.gep(builder, state_ptr, 0, 1)


def get_next_int32(context, builder, state_ptr):
    """
    Get the next int32 generated by the PRNG at *state_ptr*.
    """
    idxptr = get_index_ptr(builder, state_ptr)
    idx = builder.load(idxptr)
    need_reshuffle = builder.icmp_unsigned('>=', idx, N_const)
    with cgutils.if_unlikely(builder, need_reshuffle):
        fnty = ir.FunctionType(ir.VoidType(), (rnd_state_ptr_t,))
        fn = builder.function.module.get_or_insert_function(fnty, "numba_rnd_shuffle")
        builder.call(fn, (state_ptr,))
        builder.store(const_int(0), idxptr)
    idx = builder.load(idxptr)
    array_ptr = get_array_ptr(builder, state_ptr)
    y = builder.load(cgutils.gep(builder, array_ptr, 0, idx))
    idx = builder.add(idx, const_int(1))
    builder.store(idx, idxptr)
    # Tempering
    y = builder.xor(y, builder.lshr(y, const_int(11)))
    y = builder.xor(y, builder.and_(builder.shl(y, const_int(7)),
                                    const_int(0x9d2c5680)))
    y = builder.xor(y, builder.and_(builder.shl(y, const_int(15)),
                                    const_int(0xefc60000)))
    y = builder.xor(y, builder.lshr(y, const_int(18)))
    return y

def get_py_state_ptr(context, builder):
    return context.get_c_value(builder, rnd_state_t,
                               "numba_py_random_state")


@register
@implement("random.seed", types.uint32)
def seed_impl(context, builder, sig, args):
    seed_value, = args
    state_ptr = get_py_state_ptr(context, builder)
    fnty = ir.FunctionType(ir.VoidType(), (rnd_state_ptr_t, int32_t))
    fn = builder.function.module.get_or_insert_function(fnty, "numba_rnd_init")
    builder.call(fn, (state_ptr, seed_value))
    return context.get_constant(types.none, None)

@register
@implement("random.random")
def random_impl(context, builder, sig, args):
    state_ptr = get_py_state_ptr(context, builder)

    # a = rk_random(state) >> 5, b = rk_random(state) >> 6;
    a = builder.lshr(get_next_int32(context, builder, state_ptr), const_int(5))
    b = builder.lshr(get_next_int32(context, builder, state_ptr), const_int(6))

    # return (a * 67108864.0 + b) / 9007199254740992.0;
    a = builder.uitofp(a, double)
    b = builder.uitofp(b, double)
    return builder.fdiv(
        builder.fadd(b, builder.fmul(a, ir.Constant(double, 67108864.0))),
        ir.Constant(double, 9007199254740992.0))

@register
@implement("random.getrandbits", types.uint32)
def getrandbits_impl(context, builder, sig, args):
    nbits, = args
    state_ptr = get_py_state_ptr(context, builder)

    def get_shifted_int(nbits):
        shift = builder.sub(const_int(32), nbits)
        y = get_next_int32(context, builder, state_ptr)
        return builder.lshr(y, shift)

    ret = cgutils.alloca_once_value(builder, ir.Constant(int64_t, 0))

    is_32b = builder.icmp_unsigned('<=', nbits, const_int(32))
    with cgutils.ifelse(builder, is_32b) as (ifsmall, iflarge):
        with ifsmall:
            low = get_shifted_int(nbits)
            builder.store(builder.zext(low, int64_t), ret)
        with iflarge:
            # XXX This assumes nbits <= 64
            low = get_next_int32(context, builder, state_ptr)
            high = get_shifted_int(builder.sub(nbits, const_int(32)))
            total = builder.add(
                builder.zext(low, int64_t),
                builder.shl(builder.zext(high, int64_t), ir.Constant(int64_t, 32)))
            builder.store(total, ret)

    return builder.load(ret)
